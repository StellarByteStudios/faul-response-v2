{
  "tasks": [
    "Vokabeln",
    "Ship",
    "Skytale",
    "Plateau",
    "References",
    "Pascal",
    "Rectangle"
  ],
  "quality": {
    "options": {
      "good1": {
        "label": "Gut",
        "text": [
          "Sehr gute Abgabe. Weiter so! :)",
          "Schöne Lösung, gefällt mir! :)",
          "Schöne Abgabe, gefällt mir! :)",
          "Gute Lösung, weiter so! :)",
          "So muss das. Weiter so! :)",
          "Prima gemacht, weiter so! :)",
          "Gute Abgabe. Super gemacht :)"
        ]
      },
      "good2": {
        "label": "Gut (Simpel)",
        "text": [
          "Alles richtig!",
          "Komplett richtig!"
        ]
      },
      "goodWithError": {
        "label": "Gut mit einem Fehler",
        "text": "Gut gemacht, allerdings hat sich noch ein Fehler eingeschlichen:"
      },
      "goodWithErrors": {
        "label": "Gut mit kleinen Fehlern",
        "text": "Gut gemacht, allerdings haben sich noch ein paar Fehler eingeschlichen:"
      },
      "bad": {
        "label": "Schlecht/Musterlösung",
        "text": "Guter Ansatz, aber das ist noch nicht ganz richtig. Am besten guckst du mal in die Musterlösung und/oder besuchst das Tutorium. Wenn du nicht weiterkommst, zögere nicht, uns zu fragen."
      },
      "wrongReason": {
        "label": "Falsche Begründungen",
        "text": "Leider sind deine Begründungen nicht sehr überzeugend/falsch."
      },
      "noCompile": {
        "label": "Compiliert nicht",
        "text": "Leider kompiliert dein Programm nicht. Am besten testest du vor der Abgabe zumindest mal, ob das Programm überhaupt kompiliert. Oft wird einem bei der Fehlermeldung auch gesagt, was man falsch gemacht hat. Ansonsten kannst du natürlich immer gerne an sämtlichen Stellen nachfragen, wenn du nicht mehr weiter kommst.\nExplizit bei dir kompiliert es nicht aufgrund [Grund angeben]"
      },
      "wrongFileName": {
        "label": "Dateiname falsch",
        "text": "Schade, leider hast du deine Datei falsch benannt, sie sollte [Dateiname] heißen. Deshalb gibt es für diese Abgabe keine Punkte. Achte das nächste mal darauf, dass die Tests durchlaufen."
      },
      "wrongClassName": {
        "label": "Klassennamen falsch",
        "text": "Leider hast du deine Klasse falsch benannt, der Name muss exakt wie auf dem Übungsblatt sein. Deshalb gibt es für diese Abgabe keine Punkte. Achte das nächste mal darauf, dass die Tests durchlaufen."
      },
      "wrongDirec": {
        "label": "Falsches Verzeichniss",
        "text": "Du hast leider das Programm im Falschen Ordner abgegeben, da wir feste Abgabevorschriften haben, kann ich das Programm leider nicht bewerten :("
      },
      "noFiles": {
        "label": "Leere Abgabe",
        "text": [
          "Schade, nichts abgegeben :(",
          "Es wurde leider nichts abgegeben :("
        ]
      }
    }
  },
  "taskErrors": {
    "options": {
      "allArgsUsedBeforeCheck": {
        "label": "Argument verwendet vor Check",
        "text": "- Du hast ein Argument verwendet (also auf `args[n-1]` zugegriffen), bevor du überprüft hast, ob es überhaupt existiert (also überprüft hast, ob `args.length` mindestens `n`). Das kann zu Abstürzen führen."
      },
      "wrongFormat": {
        "task": "__all__",
        "label": "Falsches Ausgabeformat",
        "text": "- Leider hast du dich nicht an das Ausgabeformat gehalten. So laufen unsere Tests nicht durch. Auch wenn es an manchen Stellen hier etwas banal klingt ist es vor allem später unglaublich wichtig sich wirklich an die Vorgaben zu halten, wie ein Programm Dinge aus und zurück gibt. Allerspätestens wenn man mit mehreren Personen arbeitet."
      },
      "vokabelnToCharArray": {
        "task": "Vokabeln",
        "label": "Vokabeln: toCharArray()",
        "text": "Es gibt in Java selbst eine Methode namens `toCharArray()`. Diese kann man auf einem String aufrufen, wenn man diesen als `char[]` haben will. Solche Abkürzungen sich zu suchen ist immer ganz praktisch, da man sich so viel Zeit spart.\nWeiteres dazu gibts hier: https://docs.oracle.com/javase%2F7%2Fdocs%2Fapi%2F%2F/java/lang/String.html#toCharArray()"
      },
      "vokabelnNoGarantyMix": {
        "task": "Vokabeln",
        "label": "Vokabeln: Keine Mixed - Garantie",
        "text": "Deine Vokabeln werden zwar durchgemixt, jedoch kann es bei dir vorkommen, dass die Vokabeln wieder zufällig in der richtigen Reihenfolge auftauchen. Das sollte nicht passieren. Du musst überprüfen, ob das geshuffelte Wort nicht gleich dem Originalwort ist. Falls die beiden gleich sind, musst du so lange das shuffeln wiederholen, bis du ein neues Wort raus hast."
      },
      "shipNicePic": {
        "task": "Ship",
        "label": "Ship: Schönes Bild",
        "text": "Ein sehr kreatives Bild, find ich schön :)"
      },
      "skytaleNo28Check": {
        "task": "Skytale",
        "label": "Skytale: Kein 28 Länge Check",
        "text": "- Du hast vergessen zu überprüfen, ob die Nachricht genau 28 Zeichen hat."
      },
      "plateauWithOneForLoop": {
        "task": "Plateau",
        "label": "Plateau: Zwei for Schleifen",
        "text": "- Wenn du sehen willst, wie das ganze mit nur einer for Schleife geht, schau dir mal die Musterlösung an."
      },
      "referencesHeapStack": {
        "task": "References",
        "label": "References: Heap/Stack",
        "text": "Du hast leider nicht erwähnt, wie das Zusammenspiel von Heap und Stack bei dieser Aufgabe ist.\nDas wichtigste hierbei ist, das auf dem Stack die Variablen der Methoden sind, was in der Regel alle primitiven Datentypen betrifft. Diese sind dann jeweils nur im Scope der eigenen Methoden verfügbar, bzw. wirken sich nur in diesem Scope aus. Auf dem Heap wiederrum liegen Daten, welche persistenter sind und über Methoden hinweg gehen. Verändert man diese, werden die Veränderungen auch Global übernommen."
      },
      "referencesExample": {
        "task": "References",
        "label": "References: Allgemeine Erklärung",
        "text": "Schönes anschauliches Beispiel für den Unterschied von Referenz und Objekt-Daten [haben wir seit 22/23 auch im Ilias]:\n\nStelle dir vor zu hast einen allgemeinen Spind und einen Schlüssel dazu. Wenn du jemandem Zugriff gewähren möchtest, gibst du ihm nicht den Spind und auch nicht deinen Schlüssel, sondern eine Kopie des Schlüssels. Auf so einem Schlüssel steht dann immer eine Spindnummer, damit man weiß, zu welchem Spind der Schlüssel gehört.\n\nDer Spind stellt die Objekt-Daten dar, dein Schlüssel ist die Referenz in der `main` und die Kopie des Schlüssels ist der Parameter.\n\nWenn jetzt die Person, der du den Schlüssel gegeben hast, den Schlüssel verändert, verändert sich nichts an deinem Schlüssel und auch nichts am Spind, aber wenn diese Person den Spind leerräumt, hat das auch eine Auswirkung auf dich.\n\nAusgabe 3 wäre der Fall, dass die Person den Schlüssel verändert. Ausgabe 2 hingegen ist der Fall dass der Spind leergeräumt wird. Bei Ausgabe 1 gibt es keinen Schlüssel und du sagst der Person einfach, was sich in dem Spind befindet."
      },
      "pascalNoRecursive": {
        "task": "Pascal",
        "label": "Pascal: Keine Rekursion",
        "text": "In der Aufgabe war klar gefordert, die berechnung der Zahlen Rekursiv zu machen. Das hast du leider nicht gemacht"
      },
      "rectangleUsedStatic": {
        "task": "Rectangle",
        "label": "Rectangle: Statische Sachen benutzt",
        "text": "In der Aufgabe sollten wir uns eine Klasse so schreiben, dass wir sie als Instanzen, als Datentypen verwenden können.\n\nEs scheint, als wäre dir noch nicht so ganz klar, was der unterschied zwischen statisch und nicht-statisch ist. Ich werde das hier nur kurz anschneiden:\n\nWenn wir eine Klasse haben, welche Funktionen hat, welche immer das gleiche Verhalten (ein statisches) haben, dann nutzen wir statische Methoden und Variablen. Ein Beispiel dafür wäre die Klasse `Math` und ihre statsische Methode `Math.sqrt()`. Wir wollen natürlich nicht, dass die Wurzel von der Mathklasse abhängt, sonder nur von den Eingabeparametern.\nEin nicht-statischer Fall wäre eine Methode auf Strings, die ihr schon kennengelernt habt. Hier als Beispiel `myString.toCharArray()` das Array das da raus kommt soll natürlich von der Variable `myString` abhängen."
      },
      "rectangleSimplerSquare": {
        "task": "Rectangle",
        "label": "Rectangle: isSquare() geht einfacher",
        "text": "In isSquare() könntest du auch direkt `return width == height;` schreiben. Das ist wesentlich einfacher, übersichtlicher und sogar ein wenig performanter"
      }
    }
  },
  "syntaxErrors": {
    "intro": "Zur Syntax:",
    "options": {
      "indent": {
        "label": "Einrückung fehlerhaft",
        "text": "- Achte bitte auf die Einrückung, damit der Code lesbar wird. (siehe Vorlesung 1)"
      },
      "badVariableName": {
        "label": "Variable unschön benannt",
        "text": "- Achte auf deine Variablen/Methodenbezeichnungen, damit klar ist, was sie speichern/machen.\n a, foo, tmp sind beispielsweise keine guten Namen."
      },
      "ifWhileForInline": {
        "label": "if/while/for/else inline",
        "text": "- Bitte nutze keine Einzeiler für if/while/for/else Blöcke. Wir wollen eine Anweisung pro Zeile (mit ganz speziellen Ausnahmen) schreiben."
      },
      "ifWhileForWithoutBraces": {
        "label": "if/while/for/else ohne Klammern",
        "text": "- Bitte nutze nach if/while/for/else immer die `{ }` Klammern."
      },
      "toManyBlankLines": {
        "label": "Zu viele Leerzeilen",
        "text": "- Du hast ein paar viele Leerzeilen verwendet."
      },
      "noBlankLines": {
        "label": "Keine Leerzeilen",
        "text": "- Du hast keine Leerzeilen verwendet. Mit Leerzeilen kannst du logische Blöcke voneinander trennen, das macht den Code leichter lesbar."
      },
      "wrongCasing": {
        "label": "Falsche Groß-/Kleinschreibung",
        "text": "- Achte auf die Java Konventionen zur Groß-/Kleinschreibung: Variablennamen/Methodennamen werden in lowerCamelCase geschrieben und Klassennamen in UpperCamelCase. (s. Vorlesungsfolien 2)"
      },
      "commentsMissing": {
        "label": "Kommentare fehlen",
        "text": "- Hier wäre es vielleicht sinnvoll, Kommentare zu schreiben, besonders an den schweren Stellen (wie mehreren `for` Schleifen ineinander) oder bei der Behandlung von Sonderfällen."
      }
    }
  },
  "extra": {
    "intro": "Weitere Anmerkung(en):",
    "options": {
      "==insteadOfEquals": {
        "label": "== statt equals",
        "text": "- Verwende `.equals` statt `==` um Strings zu vergleichen."
      },
      "system.exit": {
        "label": "System.exit",
        "text": "- Bitte kein `System.exit()` nutzen, unsere Tests mögen das nicht."
      },
      "misleadingErrorMessages": {
        "label": "Irreführende Fehlermeldungen",
        "text": "- Bitte achte darauf, dass deine Fehlermeldungen nicht \"falsch\" sind. Wenn du beispielsweise auf `args.length != 1` prüfst, deine Fehlermeldung aber *\"ERROR: Keine Argumente übergeben\"* lautet, bekommt der Nutzer die Fehlermeldung auch, wenn er 2 oder mehr Argumente übergibt. Das ist irreführend."
      },
      "blaError": {
        "label": "Nichts aussagende Fehlermeldung",
        "text": "- Bitte achte darauf, dass deine Fehlermeldungen etwas aussagen. Wenn du beispielsweise auf `args.length != 1` prüfst, deine Fehlermeldung aber *\"ERROR: Error\"* lautet, weiß der Nutzer nicht, was er falsch gemacht hat. (Ja, das mag nervig sein, aber es ist wichtig, das direkt zu üben und sich zu verinnerlichen.)"
      },
      "errorElseNester": {
        "label": "Fehler verschachtelt (mit else)",
        "text": "- Bitte beende dein Programm bei der Überprüfung der Nutzereingabe bei fehlerhafter Eingabe mit einem `return` und verwende keinen else Block für den eigentlichen Code. Bei vielen Fehlerüberprüfungen kann es sonst passieren, dass du ganz viele `else` Blöcke hast und der eigentliche Code ganz weit eingerückt ist. Also aus \n\n ```java\n if(args.length != 1){\n    ...\n} else {\n    // Der eigentliche Code\n}\n```\n\n wird \n\n```java\nif(args.length != 1){\n    ...\n    return;\n}\n// Der eigentliche Code\n```"
      },
      "stupidErrorElseNester": {
        "label": "Fehler verschachtelt (mit else) - trotz return",
        "text": "- Wenn du in der Fehlerüberprüfung `return` verwendest, kannst du den eigentlichen Code auch ohne `else` schreiben. Also aus \n\n ```java\n if(args.length != 1){\n    ...\n    return;\n}\nelse {\n    // Der eigentliche Code\n}\n```\n\n wird \n\n```java\nif(args.length != 1){\n    ...\n    return;\n}\n// Der eigentliche Code\n```"
      },
      "ErrorIfNester": {
        "label": "Fehler verschachtelt (mit if)",
        "text": "- Es ist oft sinnvoll, zuerst auf die Fehler zu überprüfen, und dann den eigentlichen Code auszuführen. Sonst kann es bei vielen Fehlerüberprüfungen passieren, dass du ganz viele verschachtelte if Blöcke hast und der eigentliche Code ganz weit eingerückt ist. Also aus \n\n ```java\n if(args.length > 0){\n    // Der eigentliche Code\n} else {\n    //Fehlermeldung\n}\n```\n\n wird \n\n```java\nif(args.length == 0){\n    //Fehlermeldung\n    return;\n}\n// Der eigentliche Code\n```"
      },
      ".class": {
        "label": ".class Datei hochgeladen",
        "text": "- Die .class Datein brauchen wir nicht, bitte nur die .java Datei hochladen."
      },
      "onlyOneFile": {
        "label": "Nur eine Datei",
        "text": "- Lade bitte nur immer eine Datei (sofern nicht anders angegeben) hoch. Falls du mal eine falsche Datei hochlädst, lösche sie bitte wieder. [Wie das geht kannst du im Tutorial zum Abgabesystem nachlesen](https://hsp.pages.cs.uni-duesseldorf.de/programmierung/website/lectures/progra/tutorials/classroom/#falsch-hochgeladene-dateien-l%C3%B6schen)."
      },
      "scannerWithSystemInClosed": {
        "label": "Scanner mit System.in geschlossen",
        "text": "- An sich ist es richtig, dass wir einen Scanner schließen, das ist bei Java mit System.in aber ein Sonderfall: einen Scanner auf System.in wollen wir in Java meistens nie selber schließen: https://coderanch.com/wiki/678613/Don-close-Scanner-tied-System"
      },
      "errorStreamInsteadOfOut": {
        "label": "System.err statt System.out",
        "text": "- Bitte verwende `System.out` statt `System.err` für die Ausgabe. Unsere Tests prüfen nur `System.out`."
      }
    }
  }
}